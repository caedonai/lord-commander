/**
 * Shell Autocomplete Core Module
 * 
 * Provides comprehensive shell completion support for CLI applications built with the SDK.
 * Supports bash, zsh, fish, and PowerShell with command, option, and argument completion.
 */

import { Command } from 'commander';
import { exec } from '../execution/exec.js';
import { createLogger } from '../ui/logger.js';

export interface CompletionOptions {
  /**
   * Custom completion function for command arguments
   */
  argumentCompletion?: (partial: string, command: string) => Promise<string[]> | string[];
  
  /**
   * Custom completion function for option values
   */
  optionCompletion?: (partial: string, option: string, command: string) => Promise<string[]> | string[];
  
  /**
   * Enable file/directory completion for arguments
   */
  enableFileCompletion?: boolean;
  
  /**
   * Shell-specific completion customizations
   */
  shellCustomizations?: {
    bash?: string;
    zsh?: string;
    fish?: string;
    powershell?: string;
  };
}

export interface CompletionContext {
  /**
   * The CLI program instance
   */
  program: Command;
  
  /**
   * CLI name for completion scripts
   */
  cliName: string;
  
  /**
   * Analyzed commands
   */
  commands: Array<{
    name: string;
    aliases: string[];
    description: string;
    options: Array<{
      flags: string;
      description: string;
      required: boolean;
    }>;
    arguments: Array<{
      name: string;
      required: boolean;
      variadic: boolean;
    }>;
  }>;
  
  /**
   * Global options available to all commands
   */
  globalOptions: Array<{
    flags: string;
    description: string;
  }>;
  
  /**
   * Completion options
   */
  options?: CompletionOptions;
}

/**
 * Extract all commands, options, and arguments from a Commander program
 */
export function analyzeProgram(program: Command, cliName?: string): CompletionContext {
  const commands: any[] = [];
  const globalOptions: any[] = [];

  // Extract global options
  program.options.forEach(option => {
    globalOptions.push({
      flags: option.flags,
      description: option.description || ''
    });
  });

  // Extract commands recursively
  function extractCommands(cmd: Command, parentName = '') {
    cmd.commands.forEach(subCmd => {
      const fullName = parentName ? `${parentName} ${subCmd.name()}` : subCmd.name();
      
      const cmdInfo = {
        name: fullName,
        aliases: (subCmd as any)._aliases || [],
        description: subCmd.description() || '',
        options: [] as any[],
        arguments: [] as any[]
      };

      // Extract command options
      subCmd.options.forEach(option => {
        cmdInfo.options.push({
          flags: option.flags,
          description: option.description || '',
          required: option.required || false
        });
      });

      // Extract command arguments
      subCmd.registeredArguments?.forEach(arg => {
        cmdInfo.arguments.push({
          name: arg.name(),
          required: arg.required,
          variadic: arg.variadic
        });
      });

      commands.push(cmdInfo);

      // Recursively extract subcommands
      if (subCmd.commands.length > 0) {
        extractCommands(subCmd, fullName);
      }
    });
  }

  extractCommands(program);

  return { 
    program, 
    cliName: cliName || program.name() || 'cli',
    commands, 
    globalOptions 
  };
}

/**
 * Generate bash completion script
 */
export function generateBashCompletion(context: CompletionContext): string {
  const { cliName, options, commands, globalOptions } = context;

  const commandNames = commands.map(cmd => cmd.name).join(' ');
  const globalOptionFlags = globalOptions
    .map(opt => opt.flags.split(',')[0].trim())
    .join(' ');

  const bashScript = `#!/bin/bash
# ${cliName} bash completion script
# Generated by Lord Commander SDK

_${cliName}_completion() {
    local cur prev opts commands
    COMPREPLY=()
    cur="\${COMP_WORDS[COMP_CWORD]}"
    prev="\${COMP_WORDS[COMP_CWORD-1]}"

    # Available commands
    commands="${commandNames}"
    
    # Global options
    opts="${globalOptionFlags} help version"

    # Complete commands
    if [[ \${COMP_CWORD} == 1 ]]; then
        COMPREPLY=( $(compgen -W "\${commands} \${opts}" -- \${cur}) )
        return 0
    fi

    # Complete command-specific options
    case "\${COMP_WORDS[1]}" in
${commands.map(cmd => {
  const cmdOptions = cmd.options
    .map(opt => opt.flags.split(',')[0].trim())
    .join(' ');
  
  return `        "${cmd.name}")
            COMPREPLY=( $(compgen -W "${cmdOptions} ${globalOptionFlags}" -- \${cur}) )
            return 0
            ;;`;
}).join('\n')}
    esac

    ${options?.enableFileCompletion ? `
    # File/directory completion for arguments
    if [[ "\${cur}" != -* ]]; then
        COMPREPLY=( $(compgen -f -- \${cur}) )
        return 0
    fi` : ''}

    ${options?.shellCustomizations?.bash || ''}
}

complete -F _${cliName}_completion ${cliName}
`;

  return bashScript;
}

/**
 * Generate zsh completion script
 */
export function generateZshCompletion(context: CompletionContext): string {
  const { cliName, options, commands, globalOptions } = context;

  const zshScript = `#compdef ${cliName}
# ${cliName} zsh completion script
# Generated by Lord Commander SDK

_${cliName}() {
    local context curcontext="$curcontext" state line
    typeset -A opt_args

    _arguments -C \\
${globalOptions.map(opt => {
  const shortFlag = opt.flags.match(/-([a-zA-Z])/)?.[1];
  const longFlag = opt.flags.match(/--([a-zA-Z0-9-]+)/)?.[1];
  const flags = [shortFlag && `-${shortFlag}`, longFlag && `--${longFlag}`].filter(Boolean).join(',');
  return `        '${flags}[${opt.description}]' \\`;
}).join('\n')}
        '1: :_${cliName}_commands' \\
        '*::arg:->args'

    case $line[1] in
${commands.map(cmd => {
  return `        ${cmd.name})
            _${cliName}_${cmd.name.replace(/[^a-zA-Z0-9]/g, '_')}_args
            ;;`;
}).join('\n')}
    esac
}

_${cliName}_commands() {
    local commands; commands=(
${commands.map(cmd => `        '${cmd.name}:${cmd.description}'`).join('\n')}
    )
    _describe 'command' commands
}

${commands.map(cmd => {
  const funcName = `_${cliName}_${cmd.name.replace(/[^a-zA-Z0-9]/g, '_')}_args`;
  const cmdOptions = cmd.options.map(opt => {
    const shortFlag = opt.flags.match(/-([a-zA-Z])/)?.[1];
    const longFlag = opt.flags.match(/--([a-zA-Z0-9-]+)/)?.[1];
    const flags = [shortFlag && `-${shortFlag}`, longFlag && `--${longFlag}`].filter(Boolean).join(',');
    return `        '${flags}[${opt.description}]' \\`;
  }).join('\n');

  return `${funcName}() {
    _arguments \\
${cmdOptions}
        ${options?.enableFileCompletion ? "'*:file:_files'" : "'*:argument:'"}
}`;
}).join('\n\n')}

${options?.shellCustomizations?.zsh || ''}

_${cliName} "$@"
`;

  return zshScript;
}

/**
 * Generate fish completion script
 */
export function generateFishCompletion(context: CompletionContext): string {
  const { cliName, options, commands, globalOptions } = context;

  let fishScript = `# ${cliName} fish completion script
# Generated by Lord Commander SDK

`;

  // Global options
  globalOptions.forEach(opt => {
    const shortFlag = opt.flags.match(/-([a-zA-Z])/)?.[1];
    const longFlag = opt.flags.match(/--([a-zA-Z0-9-]+)/)?.[1];
    
    if (shortFlag) {
      fishScript += `complete -c ${cliName} -s ${shortFlag} -d "${opt.description}"\n`;
    }
    if (longFlag) {
      fishScript += `complete -c ${cliName} -l ${longFlag} -d "${opt.description}"\n`;
    }
  });

  fishScript += '\n';

  // Commands
  commands.forEach(cmd => {
    fishScript += `complete -c ${cliName} -f -a "${cmd.name}" -d "${cmd.description}"\n`;
    
    // Command-specific options
    cmd.options.forEach(opt => {
      const shortFlag = opt.flags.match(/-([a-zA-Z])/)?.[1];
      const longFlag = opt.flags.match(/--([a-zA-Z0-9-]+)/)?.[1];
      
      const condition = `__fish_seen_subcommand_from ${cmd.name}`;
      
      if (shortFlag) {
        fishScript += `complete -c ${cliName} -s ${shortFlag} -n "${condition}" -d "${opt.description}"\n`;
      }
      if (longFlag) {
        fishScript += `complete -c ${cliName} -l ${longFlag} -n "${condition}" -d "${opt.description}"\n`;
      }
    });
  });

  if (options?.enableFileCompletion) {
    fishScript += `\n# Enable file completion for arguments\n`;
    fishScript += `complete -c ${cliName} -f\n`;
  }

  if (options?.shellCustomizations?.fish) {
    fishScript += `\n${options.shellCustomizations.fish}\n`;
  }

  return fishScript;
}

/**
 * Generate PowerShell completion script
 */
export function generatePowerShellCompletion(context: CompletionContext): string {
  const { program, cliName, options } = context;
  const { commands, globalOptions } = analyzeProgram(program);

  const powershellScript = `# ${cliName} PowerShell completion script
# Generated by Lord Commander SDK

Register-ArgumentCompleter -Native -CommandName ${cliName} -ScriptBlock {
    param($commandName, $wordToComplete, $cursorPosition)
    
    $commands = @(
${commands.map(cmd => `        "${cmd.name}"`).join(',\n')}
    )
    
    $globalOptions = @(
${globalOptions.map(opt => {
  const longFlag = opt.flags.match(/--([a-zA-Z0-9-]+)/)?.[1];
  return longFlag ? `        "--${longFlag}"` : null;
}).filter(Boolean).join(',\n')}
    )
    
    # Get the current command line
    $commandElements = $wordToComplete.Split(' ')
    $lastElement = $commandElements[-1]
    
    # Complete commands
    if ($commandElements.Length -le 2) {
        $completions = $commands + $globalOptions | Where-Object { $_ -like "$lastElement*" }
        $completions | ForEach-Object {
            [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
        }
        return
    }
    
    # Complete command-specific options
    $command = $commandElements[1]
    switch ($command) {
${commands.map(cmd => {
  const cmdOptions = cmd.options
    .map(opt => opt.flags.match(/--([a-zA-Z0-9-]+)/)?.[1])
    .filter(Boolean)
    .map(flag => `"--${flag}"`);
  
  return `        "${cmd.name}" {
            $options = @(${cmdOptions.join(', ')})
            $completions = $options + $globalOptions | Where-Object { $_ -like "$lastElement*" }
            $completions | ForEach-Object {
                [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
            }
        }`;
}).join('\n        ')}
    }
    
    ${options?.enableFileCompletion ? `
    # File completion for arguments
    if ($lastElement -notmatch '^-') {
        Get-ChildItem -Path "$lastElement*" | ForEach-Object {
            [System.Management.Automation.CompletionResult]::new($_.Name, $_.Name, 'ProviderItem', $_.Name)
        }
    }` : ''}
    
    ${options?.shellCustomizations?.powershell || ''}
}
`;

  return powershellScript;
}

/**
 * Result of completion installation/uninstallation
 */
export interface CompletionResult {
  success: boolean;
  error?: string;
  restartRequired?: boolean;
  activationCommand?: string;
}

/**
 * Options for completion installation
 */
export interface InstallationOptions {
  shell?: 'bash' | 'zsh' | 'fish' | 'powershell';
  global?: boolean;
  force?: boolean;
}

/**
 * Status information for completion installation
 */
export interface CompletionStatus {
  shell: 'bash' | 'zsh' | 'fish' | 'powershell';
  cliName: string;
  installed: boolean;
  installationPath?: string;
  installationType?: 'global' | 'local';
  isActive?: boolean;
  errorMessage?: string;
}

/**
 * Generate completion script (alias for generateCompletionScript)
 */
export function generateCompletion(
  program: Command,
  shell: 'bash' | 'zsh' | 'fish' | 'powershell'
): string {
  const context = analyzeProgram(program);
  return generateCompletionScript(context, shell);
}

/**
 * Install completion script for the current shell
 */
export async function installCompletion(
  program: Command,
  options: InstallationOptions = {}
): Promise<CompletionResult> {
  const context = analyzeProgram(program);
  const { cliName } = context;
  
  // Detect shell if not specified
  let shell = options.shell;
  if (!shell) {
    shell = await detectShell();
  }

  const logger = createLogger();
  logger.info(`Installing ${shell} completion for ${cliName}...`);

  let script: string;
  let installPath: string;
  let installCommand: string;

  switch (shell) {
    case 'bash':
      script = generateBashCompletion(context);
      installPath = options.global 
        ? `/etc/bash_completion.d/${cliName}`
        : `~/.local/share/bash-completion/completions/${cliName}`;
      installCommand = options.global
        ? `echo '${script}' | sudo tee ${installPath} > /dev/null`
        : `mkdir -p ~/.local/share/bash-completion/completions && echo '${script}' > ${installPath}`;
      break;

    case 'zsh':
      script = generateZshCompletion(context);
      installPath = options.global 
        ? `/usr/local/share/zsh/site-functions/_${cliName}`
        : `~/.zsh/completions/_${cliName}`;
      installCommand = options.global
        ? `echo '${script}' | sudo tee ${installPath} > /dev/null`
        : `mkdir -p ~/.zsh/completions && echo '${script}' > ${installPath}`;
      break;

    case 'fish':
      script = generateFishCompletion(context);
      installPath = options.global
        ? `/usr/share/fish/completions/${cliName}.fish`
        : `~/.config/fish/completions/${cliName}.fish`;
      installCommand = options.global
        ? `echo '${script}' | sudo tee ${installPath} > /dev/null`
        : `mkdir -p ~/.config/fish/completions && echo '${script}' > ${installPath}`;
      break;

    case 'powershell':
      script = generatePowerShellCompletion(context);
      return {
        success: false,
        error: 'PowerShell completion requires manual installation',
        restartRequired: false,
        activationCommand: 'Add the completion script to your PowerShell profile'
      };

    default:
      return {
        success: false,
        error: `Unsupported shell: ${shell}`,
        restartRequired: false
      };
  }

  try {
    await exec('bash', ['-c', installCommand]);
    return {
      success: true,
      restartRequired: true,
      activationCommand: shell === 'bash' ? `source ${installPath}` : `exec ${shell}`
    };
  } catch (error) {
    return {
      success: false,
      error: `Failed to install completion: ${error}`,
      restartRequired: false
    };
  }
}

/**
 * Detect the current shell
 */
export async function detectShell(): Promise<'bash' | 'zsh' | 'fish' | 'powershell'> {
  const shell = process.env.SHELL || '';
  
  if (shell.includes('zsh')) return 'zsh';
  if (shell.includes('fish')) return 'fish';
  if (shell.includes('bash')) return 'bash';
  
  // Check for PowerShell on Windows
  if (process.platform === 'win32') {
    return 'powershell';
  }
  
  return 'bash'; // Default fallback
}

/**
 * Generate completion script for specified shell
 */
/**
 * Uninstall completion script for the specified shell
 */
export async function uninstallCompletion(
  program: Command,
  options: InstallationOptions = {}
): Promise<CompletionResult> {
  const context = analyzeProgram(program);
  const { cliName } = context;
  
  // Detect shell if not specified
  let shell = options.shell;
  if (!shell) {
    shell = await detectShell();
  }

  const logger = createLogger();
  logger.info(`Uninstalling ${shell} completion for ${cliName}...`);

  let installPath: string;
  let removeCommand: string;

  switch (shell) {
    case 'bash':
      installPath = options.global 
        ? `/etc/bash_completion.d/${cliName}`
        : `~/.local/share/bash-completion/completions/${cliName}`;
      removeCommand = options.global
        ? `sudo rm -f ${installPath}`
        : `rm -f ${installPath}`;
      break;

    case 'zsh':
      installPath = options.global 
        ? `/usr/local/share/zsh/site-functions/_${cliName}`
        : `~/.zsh/completions/_${cliName}`;
      removeCommand = options.global
        ? `sudo rm -f ${installPath}`
        : `rm -f ${installPath}`;
      break;

    case 'fish':
      installPath = options.global
        ? `/usr/share/fish/completions/${cliName}.fish`
        : `~/.config/fish/completions/${cliName}.fish`;
      removeCommand = options.global
        ? `sudo rm -f ${installPath}`
        : `rm -f ${installPath}`;
      break;

    case 'powershell':
      return {
        success: false,
        error: 'PowerShell completion requires manual removal from your profile',
        restartRequired: false
      };

    default:
      return {
        success: false,
        error: `Unsupported shell: ${shell}`,
        restartRequired: false
      };
  }

  try {
    await exec('bash', ['-c', removeCommand]);
    return {
      success: true,
      restartRequired: false
    };
  } catch (error) {
    return {
      success: false,
      error: `Failed to uninstall completion: ${error}`,
      restartRequired: false
    };
  }
}

/**
 * Check the installation status of shell completion
 */
export async function checkCompletionStatus(
  program: Command,
  shell?: 'bash' | 'zsh' | 'fish' | 'powershell'
): Promise<CompletionStatus> {
  const context = analyzeProgram(program);
  const { cliName } = context;
  
  // Detect shell if not specified
  if (!shell) {
    shell = await detectShell();
  }

  const status: CompletionStatus = {
    shell,
    cliName,
    installed: false
  };

  try {
    let possiblePaths: Array<{ path: string; type: 'global' | 'local' }> = [];

    switch (shell) {
      case 'bash':
        possiblePaths = [
          { path: `/etc/bash_completion.d/${cliName}`, type: 'global' },
          { path: `${process.env.HOME}/.local/share/bash-completion/completions/${cliName}`, type: 'local' },
          { path: `${process.env.HOME}/.bash_completion.d/${cliName}`, type: 'local' }
        ];
        break;

      case 'zsh':
        possiblePaths = [
          { path: `/usr/local/share/zsh/site-functions/_${cliName}`, type: 'global' },
          { path: `/usr/share/zsh/site-functions/_${cliName}`, type: 'global' },
          { path: `${process.env.HOME}/.zsh/completions/_${cliName}`, type: 'local' },
          { path: `${process.env.HOME}/.zsh/site-functions/_${cliName}`, type: 'local' }
        ];
        break;

      case 'fish':
        possiblePaths = [
          { path: `/usr/share/fish/completions/${cliName}.fish`, type: 'global' },
          { path: `${process.env.HOME}/.config/fish/completions/${cliName}.fish`, type: 'local' }
        ];
        break;

      case 'powershell':
        status.errorMessage = 'PowerShell completion status cannot be automatically detected (requires manual profile inspection)';
        return status;

      default:
        status.errorMessage = `Unsupported shell: ${shell}`;
        return status;
    }

    // Check each possible installation path
    const fs = await import('node:fs/promises');
    for (const { path, type } of possiblePaths) {
      try {
        await fs.access(path);
        status.installed = true;
        status.installationPath = path;
        status.installationType = type;
        
        // Try to determine if it's active by checking file content
        try {
          const content = await fs.readFile(path, 'utf-8');
          status.isActive = content.includes(cliName);
        } catch {
          status.isActive = undefined; // Cannot determine
        }
        
        break; // Found installation, stop checking
      } catch {
        // File doesn't exist, continue checking
      }
    }

    return status;
  } catch (error) {
    status.errorMessage = `Failed to check completion status: ${error}`;
    return status;
  }
}

export function generateCompletionScript(
  context: CompletionContext,
  shell: 'bash' | 'zsh' | 'fish' | 'powershell'
): string {
  switch (shell) {
    case 'bash':
      return generateBashCompletion(context);
    case 'zsh':
      return generateZshCompletion(context);
    case 'fish':
      return generateFishCompletion(context);
    case 'powershell':
      return generatePowerShellCompletion(context);
    default:
      throw new Error(`Unsupported shell: ${shell}`);
  }
}