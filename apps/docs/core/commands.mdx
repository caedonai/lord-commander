---
title: "Commands"
description: "Understanding command structure and implementation in Lord Commander"
---

# Commands

Commands are the fundamental building blocks of any CLI application. Lord Commander provides a robust command system that handles argument parsing, validation, and execution.

## Command Anatomy

Every command in Lord Commander follows a consistent structure:

```typescript
interface Command {
  name: string;
  description: string;
  aliases?: string[];
  arguments?: Argument[];
  options?: Option[];
  handler: CommandHandler;
}
```

### Basic Command Example

```typescript
export const initCommand: Command = {
  name: 'init',
  description: 'Initialize a new project',
  arguments: [
    {
      name: 'projectName',
      description: 'Name of the project to create',
      required: false,
      defaultValue: '.'
    }
  ],
  options: [
    {
      name: 'template',
      alias: 't',
      description: 'Project template to use',
      type: 'string',
      choices: ['react', 'vue', 'angular', 'vanilla']
    }
  ],
  handler: async (args, options, context) => {
    // Command implementation
    const projectName = args.projectName;
    const template = options.template || 'react';
    
    await createProject(projectName, template);
  }
};
```

## Command Types

<AccordionGroup>
  <Accordion icon="terminal" title="Action Commands">
    Commands that perform specific actions:
    
    ```bash
    lord-commander init my-app
    lord-commander build --production
    lord-commander deploy --environment staging
    ```
    
    These commands typically:
    - Modify the file system
    - Make network requests
    - Transform data
  </Accordion>
  
  <Accordion icon="info" title="Information Commands">
    Commands that display information:
    
    ```bash
    lord-commander --version
    lord-commander list templates
    lord-commander status
    ```
    
    These commands are usually read-only and fast to execute.
  </Accordion>
  
  <Accordion icon="wrench" title="Configuration Commands">
    Commands that manage configuration:
    
    ```bash
    lord-commander config set api.endpoint https://api.example.com
    lord-commander config get api.endpoint
    lord-commander config reset
    ```
  </Accordion>
</AccordionGroup>

## Command Composition

### Subcommands

Organize related functionality under parent commands:

```typescript
const scaffoldCommand: Command = {
  name: 'scaffold',
  description: 'Generate code from templates',
  subcommands: [
    {
      name: 'component',
      description: 'Generate a component',
      handler: generateComponent
    },
    {
      name: 'page',
      description: 'Generate a page',
      handler: generatePage
    },
    {
      name: 'service',
      description: 'Generate a service',
      handler: generateService
    }
  ]
};
```

### Command Chaining

Some commands can be chained for complex workflows:

```bash
# Initialize, scaffold, and build in sequence
lord-commander init my-app --template react && \
lord-commander scaffold component Header && \
lord-commander build
```

## Validation and Error Handling

### Input Validation

```typescript
const command: Command = {
  name: 'deploy',
  arguments: [
    {
      name: 'environment',
      required: true,
      validate: (value) => {
        const validEnvs = ['dev', 'staging', 'production'];
        if (!validEnvs.includes(value)) {
          throw new Error(`Environment must be one of: ${validEnvs.join(', ')}`);
        }
      }
    }
  ],
  handler: async (args) => {
    // Deploy logic
  }
};
```

### Graceful Error Recovery

```typescript
const handler: CommandHandler = async (args, options, context) => {
  try {
    await performOperation(args.target);
  } catch (error) {
    if (error.code === 'ENOENT') {
      context.logger.error(`File not found: ${args.target}`);
      context.logger.info('Run "lord-commander init" to create a new project');
      process.exit(1);
    }
    throw error; // Re-throw unexpected errors
  }
};
```

## Testing Commands

### Unit Testing

```typescript
import { testCommand } from '@caedonai/lord-commander/testing';

describe('init command', () => {
  it('should create a new project', async () => {
    const result = await testCommand(initCommand, {
      arguments: { projectName: 'test-project' },
      options: { template: 'react' }
    });
    
    expect(result.success).toBe(true);
    expect(fs.existsSync('test-project/package.json')).toBe(true);
  });
});
```

### Integration Testing

```typescript
import { execSync } from 'child_process';

describe('CLI integration', () => {
  it('should work end-to-end', () => {
    const output = execSync('lord-commander init test-app --template vue', {
      encoding: 'utf8'
    });
    
    expect(output).toContain('Project created successfully');
  });
});
```

## Best Practices

<CardGroup cols={2}>

<Card title="Performance" icon="gauge-high">
  - Lazy load dependencies
  - Cache expensive operations
  - Provide progress indicators
  - Use streaming for large data
</Card>

<Card title="User Experience" icon="user">
  - Clear, consistent naming
  - Helpful error messages
  - Interactive prompts when needed
  - Respect user's terminal preferences
</Card>

<Card title="Maintainability" icon="code">
  - Single responsibility per command
  - Consistent error handling
  - Comprehensive testing
  - Clear documentation
</Card>

<Card title="Compatibility" icon="puzzle-piece">
  - Follow POSIX conventions
  - Support common flags (--help, --version)
  - Handle different terminal capabilities
  - Cross-platform file paths
</Card>

</CardGroup>

## Next Steps

<CardGroup cols={2}>

<Card title="CLI Creation" icon="plus" href="/core/cli-creation">
  Learn the fundamentals of CLI design
</Card>

<Card title="Plugins" icon="plug" href="/core/plugins">
  Extend functionality with plugins
</Card>

<Card title="Build Your First CLI" icon="rocket" href="/guides/first-cli">
  Hands-on tutorial
</Card>

<Card title="Configuration" icon="gear" href="/guides/configuration">
  Learn about command configuration
</Card>

</CardGroup>